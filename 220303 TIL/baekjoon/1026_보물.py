## 문제
# 옛날 옛적에 수학이 항상 큰 골칫거리였던 나라가 있었다.
# 이 나라의 국왕 김지민은 다음과 같은 문제를 내고 큰 상금을 걸었다.
# 길이가 N인 정수 배열 A와 B가 있다. 다음과 같이 함수 S를 정의하자.
# S = A[0] × B[0] + ... + A[N-1] × B[N-1]
# S의 값을 가장 작게 만들기 위해 A의 수를 재배열하자.
# 단, B에 있는 수는 재배열하면 안 된다.
# S의 최솟값을 출력하는 프로그램을 작성하시오.

## 입력
# 첫째 줄에 N이 주어진다.
# 둘째 줄에는 A에 있는 N개의 수가 순서대로 주어지고, 셋째 줄에는 B에 있는 수가 순서대로 주어진다.
# N은 50보다 작거나 같은 자연수이고, A와 B의 각 원소는 100보다 작거나 같은 음이 아닌 정수이다.

## 출력
# 첫째 줄에 S의 최솟값을 출력한다.

## 풀이
# 1. A와 B를 각각 복제한 A_와 B_ 생성
# 2. A를 오름차순으로 정렬
# 3. B_의 max값의 index와 동일한 A_의 index에 A의 0번째 값을 대입(가장 큰 값과 가장 작은 값을 곱해야 최소값이 나올 수 있다고 판단!)
# 4. B_의 max 값의 index에 -1을 대입하고 B_의 max값을 추출(-1을 insert하지 않고 max값을 추출하면 B_의 갯수가 5가 유지되지않는다!)
# 이렇게 진행하면 B의 가장 큰 값과 A의 가장 작은 값이 같은 index에 위치하게 재배열 할 수 있다.
N = int(input())
A = list(map(int,input().split()))
B = list(map(int,input().split()))
answer = 0
B_ = B[:]
A_ = [0 for _ in A]
A.sort()
for _ in range(N):
    A_[B_.index(max(B_))] = A[0]
    A.pop(0)
    B_.insert(B_.index(max(B_)),-1)
    B_.pop(B_.index(max(B_)))
for i in range(N):
    answer += A_[i]*B[i]
print(answer)